

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>NV50- surface formats &mdash; envytools git documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="envytools git documentation" href="../index.html" />
    <link rel="up" title="Memory access and structure" href="index.html" />
    <link rel="next" title="NV50 virtual memory" href="nv50-vm.html" />
    <link rel="prev" title="NV44 host memory interface" href="nv44-host-mem.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="nv50-vm.html" title="NV50 virtual memory"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nv44-host-mem.html" title="NV44 host memory interface"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">envytools git documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory access and structure</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="nv50-surface-formats">
<span id="nv50-surface"></span><h1><a class="toc-backref" href="#id1">NV50- surface formats</a><a class="headerlink" href="#nv50-surface-formats" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#nv50-surface-formats" id="id1">NV50- surface formats</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#surface-elements" id="id3">Surface elements</a></li>
<li><a class="reference internal" href="#linear-surfaces" id="id4">Linear surfaces</a></li>
<li><a class="reference internal" href="#tiled-surfaces" id="id5">Tiled surfaces</a></li>
<li><a class="reference internal" href="#textures-mipmapping-and-arrays" id="id6">Textures, mipmapping and arrays</a></li>
<li><a class="reference internal" href="#multisampled-surfaces" id="id7">Multisampled surfaces</a></li>
<li><a class="reference internal" href="#surface-formats" id="id8">Surface formats</a><ul>
<li><a class="reference internal" href="#simple-color-surface-formats" id="id9">Simple color surface formats</a></li>
<li><a class="reference internal" href="#shared-exponent-color-format" id="id10">Shared exponent color format</a></li>
<li><a class="reference internal" href="#yuv-color-formats" id="id11">YUV color formats</a></li>
<li><a class="reference internal" href="#zeta-surface-format" id="id12">Zeta surface format</a></li>
<li><a class="reference internal" href="#compressed-texture-formats" id="id13">Compressed texture formats</a></li>
<li><a class="reference internal" href="#bitmap-surface-format" id="id14">Bitmap surface format</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nv50-storage-types" id="id15">NV50 storage types</a><ul>
<li><a class="reference internal" href="#tiled-color-storage-types" id="id16">Tiled color storage types</a></li>
<li><a class="reference internal" href="#zeta-storage-types" id="id17">Zeta storage types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nvc0-storage-types" id="id18">NVC0 storage types</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This file deals with nv50+ cards only. For older cards, see <a class="reference internal" href="nv01-surface.html#nv01-surface"><em>NV01:NV50 surface formats</em></a>.</p>
<p>A &#8220;surface&#8221; is a 2d or 3d array of elements. Surfaces are used for image
storage, and can be bound to at least the following slots on the engines:</p>
<ul class="simple">
<li>m2mf input and output buffers</li>
<li>2d source and destination surfaces</li>
<li>3d/compute texture units: the textures</li>
<li>3d color render targets</li>
<li>3d zeta render target</li>
<li>compute g[] spaces [NV50:NVC0]</li>
<li>3d/compute image units [NVC0+]</li>
<li>PCOPY input and output buffers</li>
<li>PDISPLAY: the framebuffer</li>
</ul>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">vdec stuff</p>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">NVC0 ZCULL?</p>
</div>
<p>Surfaces on nv50+ cards come in two types: linear and tiled. Linear surfaces
have a simple format, but they&#8217;re are limitted to 2 dimensions only, don&#8217;t
support arrays nor mipmapping when used as textures, cannot be used for zeta
buffers, and have lower performance than tiled textures. Tiled surfaces
can have up to three dimensions, can be put into arrays and be mipmapped,
and use custom element arrangement in memory. However, tiled surfaces need to
be placed in memory area with special storage type, depending on the surface
format.</p>
<p>Tiled surfaces have two main levels of element rearrangement: high-level and
low-level. Low-level rearrangement is quite complicated, depends on surface&#8217;s
storage type, and is hidden by the VM subsystem - if the surface is accessed
through VM with properly set storage type, only the high-level rearrangement
is visible. Thus the low-level rearrangement can only be seen when accessing
tiled system RAM directly from CPU, or accessing tiled VRAM with storage type
set to 0. Also, low-level rearrangement for VRAM uses several tricks to
distribute load evenly across memory partitions, while rearrangement for
system RAM skips them and merely reorders elements inside a roptile. High-level
rearrangement, otoh, is relatively simple, and always visible to the user -
its knowledge is needed to calculate address of a given element, or to
calculate the memory size of a surface.</p>
</div>
<div class="section" id="surface-elements">
<h2><a class="toc-backref" href="#id3">Surface elements</a><a class="headerlink" href="#surface-elements" title="Permalink to this headline">¶</a></h2>
<p>A basic unit of surface is an &#8220;element&#8221;, which can be 1, 2, 4, 8, or 16 bytes
long. element type is vital in selecting the proper compressed storage type
for a surface. For most surface formats, an element means simply a sample. This
is different for surfaces storing compressed textures - the elements are
compressed blocks. Also, it&#8217;s different for bitmap textures - in these, an
element is a 64-bit word containing 8x8 block of samples.</p>
<p>While texture, RT, and 2d bindings deal only with surface elements, they&#8217;re
ignored by some other binding points, like PCOPY and m2mf - in these, the
element size is ignored, and the surface is treated as an array of bytes. That
is, a 16x16 surface of 4-byte elements is treated as a 64x16 surface of bytes.</p>
</div>
<div class="section" id="linear-surfaces">
<h2><a class="toc-backref" href="#id4">Linear surfaces</a><a class="headerlink" href="#linear-surfaces" title="Permalink to this headline">¶</a></h2>
<p>A linear surface is a 2d array of elements, where each row is contiguous in
memory, and each row starts at a fixed distance from start of the previous
one. This distance is the surface&#8217;s &#8220;pitch&#8221;. Linear surfaces always use
storage type 0 [linear].</p>
<p>The attributes defining a linear surface are:</p>
<ul class="simple">
<li>address: 40-bit VM address, aligned to 64 bytes</li>
<li>pitch: distance between subsequent rows in bytes - needs to be a multiple
of 64</li>
<li>element size: implied by format, or defaulting to 1 if binding point is
byte-oriented</li>
<li>width: surface width in elements, only used when bounds checking / size
information is needed</li>
<li>height: surface height in elements, only used when bounds checking / size
information is needed</li>
</ul>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">check pitch, width, height min/max values. this may depend on binding
point. check if 64 byte alignment still holds on NVC0.</p>
</div>
<p>The address of element (x,y) is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">address</span> <span class="o">+</span> <span class="n">pitch</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">elem_size</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>
</div>
<p>Or, alternatively, the address of byte (x,y) is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">address</span> <span class="o">+</span> <span class="n">pitch</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="section" id="tiled-surfaces">
<h2><a class="toc-backref" href="#id5">Tiled surfaces</a><a class="headerlink" href="#tiled-surfaces" title="Permalink to this headline">¶</a></h2>
<p>A tiled surface is a 3d array of elements, stored in memory in units called
&#8220;tiles&#8221;. There are two levels of tiling. The lower-level tile is called
a &#8220;roptile&#8221; and has a fixed size. This size is 64 bytes × 4 × 1 on NV50:NVC0
cards, 64 bytes × 8 × 1 for NVC0+ cards. The higher-level tile is called
a bigtile, and is of variable size between 1×1×1 and 32×32×32 roptiles.</p>
<p>The attributes defining a tiled surface are:</p>
<ul class="simple">
<li>address: 40-bit VM address, aligned to roptile size [0x100 bytes on
NV50:NVC0, 0x200 bytes on NVC0]</li>
<li>tile size x: 0-5, log2 of roptiles per bigtile in x dimension</li>
<li>tile size y: 0-5, log2 of roptiles per bigtile in y dimension</li>
<li>tile size z: 0-5, log2 of roptiles per bigtile in z dimension</li>
<li>element size: implied by format, or defaulting to 1 if the binding point
is byte-oriented</li>
<li>width: surface width [size in x dimension] in elements</li>
<li>height: surface height [size in y dimension] in elements</li>
<li>depth: surface depth [size in z dimension] in elements</li>
</ul>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">check bounduaries on them all, check tiling on NVC0.</p>
</div>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">PCOPY surfaces with weird tile size</p>
</div>
<p>It should be noted that some limits on these parameters are to some extent
specific to the binding point. In particular, x tile size greater than 0 is
only supported by the render targets and texture units, with render targets
only supporting 0 and 1. y tile sizes 0-5 can be safely used with all tiled
surface binding points, and z tile sizes 0-5 can be used with binding points
other than NV50 g[] spaces, which only support 0.</p>
<p>The tiled format works as follows:</p>
<p>First, the big tile size is computed. This computation depends on the binding
point: some binding points clamp the effective bigtile size in a given
dimension to the smallest size that would cover the whole surfaces, some do
not. The ones that do are called &#8220;auto-sizing&#8221; binding points. One of such
binding ports where it&#8217;s important is the texture unit: since all mipmap
levels of a texture use a single &#8220;tile size&#8221; field in TIC, the auto-sizing is
needed to ensure that small mipmaps of a large surface don&#8217;t use needlessly
large tiles. Pseudocode:</p>
<div class="highlight-python"><pre>bytes_per_roptile_x = 64;
if (chipset &lt; NVC0)
    bytes_per_roptile_y = 4;
else
    bytes_per_roptile_y = 8;
bytes_per_roptile = 1;
eff_tile_size_x = tile_size_x;
eff_tile_size_y = tile_size_y;
eff_tile_size_z = tile_size_z;
if (auto_sizing) {
    while (eff_tile_size_x &gt; 0 &amp;&amp; (bytes_per_roptile_x &lt;&lt; (eff_tile_size_x - 1)) &gt;= width * element_size)
        eff_tile_size_x--;
    while (eff_tile_size_y &gt; 0 &amp;&amp; (bytes_per_roptile_y &lt;&lt; (eff_tile_size_y - 1)) &gt;= height)
        eff_tile_size_y--;
    while (eff_tile_size_z &gt; 0 &amp;&amp; (bytes_per_roptile_z &lt;&lt; (eff_tile_size_z - 1)) &gt;= depth)
        eff_tile_size_z--;
}
roptiles_per_bigtile_x = 1 &lt;&lt; eff_tile_size_x;
roptiles_per_bigtile_y = 1 &lt;&lt; eff_tile_size_y;
roptiles_per_bigtile_z = 1 &lt;&lt; eff_tile_size_z;
bytes_per_bigtile_x = bytes_per_roptile_x * roptiles_per_bigtile_x;
bytes_per_bigtile_y = bytes_per_roptile_y * roptiles_per_bigtile_y;
bytes_per_bigtile_z = bytes_per_roptile_z * roptiles_per_bigtile_z;
elements_per_bigtile_x = bytes_per_bigtile_x / element_size;
roptile_bytes = bytes_per_roptile_x * bytes_per_roptile_y * bytes_per_roptile_z;
bigtile_roptiles = roptiles_per_bigtils_x * roptiles_per_bigtile_y * roptiles_per_bigtile_z;
bigtile_bytes = roptile_bytes * bigtile_roptiles;</pre>
</div>
<p>Due to the auto-sizing being present on some binding points, it&#8217;s a bad idea
to use surfaces that have bigtile size at least two times bigger than the
actual surface - they&#8217;ll be unusable on these binding points [and waste a lot
of memory anyway].</p>
<p>Once bigtile size is known, the geometry and size of the surface can be
determined. A surface is first broken down into bigtiles. Each bigtile convers
a contiguous elements_per_bigtile_x × bytes_per_bigtile_y × bytes_per_bigtile_z
aligned subarea of the surface. If the surface size is not a multiple of the
bigtile size in any dimension, the size is aligned up for surface layout
purposes and the remaining space is unused. The bigtiles making up a surface
are stored sequentially in memory first in x direction, then in y direction,
then in z direction:</p>
<div class="highlight-python"><pre>bigtiles_per_surface_x = ceil(width * element_size / bytes_per_bigtile_x);
bigtiles_per_surface_y = ceil(height / bytes_per_bigtile_y);
bigtiles_per_surface_z = ceil(depth / bytes_per_bigtile_z);
surface_bigtiles = bigtiles_per_surface_x * bigtiles_per_surface_y * bigtiles_per_surface_z;
// total bytes in surface - surface resides at addresses [address, address+surface_bytes)
surface_bytes = surface_bigtiles * bigtile_bytes;
bigtile_address = address + floor(x_coord * element_size / bytes_per_bigtile_x) * bigtile_bytes
            + floor(y_coord / bytes_per_bigtile_y) * bigtile_bytes * bigtiles_per_surface_x;
            + floor(z_coord / bytes_per_bigtile_z) * bigtile_bytes * bigtiles_per_surface_x * bigtiles_per_surface_z;
x_coord_in_bigtile = (x_coord * element_size) % bytes_per_bigtile_x;
y_coord_in_bigtile = y_coord % bytes_per_bigtile_y;
z_coord_in_bigtile = z_coord % bytes_per_bigtile_z;</pre>
</div>
<p>Like bigtiles in the surface, roptiles inside a bigtile are stored ordered first by x coord, then by y coord, then by z coord:</p>
<div class="highlight-python"><pre>roptile_address = bigtile_address
        + floor(x_coord_in_bigtile / bytes_per_roptile_x) * roptile_bytes
        + floor(y_coord_in_bigtile / bytes_per_roptile_y) * roptile_bytes * roptiles_per_bigtile_x
        + z_coord_in_bigtile * roptile_bytes * roptiles_per_bigtile_x * roptiles_per_bigtile_y; // bytes_per_roptile_z always 1.
x_coord_in_roptile = x_coord_in_bigtile % bytes_per_roptile_x;
y_coord_in_roptile = y_coord_in_bigtile % bytes_per_roptile_y;</pre>
</div>
<p>The elements inside a roptile are likewise stored ordered first by x coordinate, and then by y:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">element_address</span> <span class="o">=</span> <span class="n">roptile_address</span> <span class="o">+</span> <span class="n">x_coord_in_roptile</span> <span class="o">+</span> <span class="n">y_coord_in_roptile</span> <span class="o">*</span> <span class="n">bytes_per_roptile_x</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the above is the higher-level rearrangement only - the element
address resulting from the above pseudocode is the address that user would see
by looking through the card&#8217;s VM subsystem. The lower-level rearrangement is
storage type dependent, invisible to the user, and will be covered below.</p>
<p>As an example, let&#8217;s take a 13 × 17 × 3 surface with element size of 16
bytes, tile size x of 1, tile size y of 1, and tile size z of 1. Further,
the card is assumed to be nv50. The surface will be located in memory the
following way:</p>
<ul class="simple">
<li>bigtile size in bytes = 0x800 bytes</li>
<li>bigtile width: 128 bytes / 8 elements</li>
<li>bigtile height: 8</li>
<li>bigtile depth: 2</li>
<li>surface width in bigtiles: 2</li>
<li>surface height in bigtiles: 3</li>
<li>surface depth in bigtiles: 2</li>
<li>surface memory size: 0x6000 bytes</li>
</ul>
<div class="highlight-python"><pre>| - x element bounduary
|| - x roptile bounduary
||| - x bigtile bounduary
[no line] - y element bounduary
--- - y roptile bounduary
=== - y bigtile bounduary

z == 0:
 x --&gt;
y+--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
||  |  0 |  1 |  2 |  3 ||  4 |  5 |  6 |  7 |||  8 |  9 | 10 | 11 || 12 |
|+--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
V| 0|0000|0010|0020|0030||0100|0110|0120|0130|||0800|0810|0820|0830||0900|
 | 1|0040|0050|0060|0070||0140|0150|0160|0170|||0840|0850|0860|0870||0940|
 | 2|0080|0090|00a0|00b0||0180|0190|01a0|01b0|||0880|0890|08a0|08b0||0980|
 | 3|00c0|00d0|00e0|00f0||01c0|01d0|01e0|01f0|||08c0|08d0|08e0|08f0||09c0|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
 | 4|0200|0210|0220|0230||0300|0310|0320|0330|||0a00|0a10|0a20|0a30||0b00|
 | 5|0240|0250|0260|0270||0340|0350|0360|0370|||0a40|0a50|0a60|0a70||0b40|
 | 6|0280|0290|02a0|02b0||0380|0390|03a0|03b0|||0a80|0a90|0aa0|0ab0||0b80|
 | 7|02c0|02d0|02e0|02f0||03c0|03d0|03e0|03f0|||0ac0|0ad0|0ae0|0af0||0bc0|
 +==+====+====+====+====++====+====+====+====+++====+====+====+====++====+
 | 8|1000|1010|1020|1030||1100|1110|1120|1130|||1800|1810|1820|1830||1900|
 | 9|1040|1050|1060|1070||1140|1150|1160|1170|||1840|1850|1860|1870||1940|
 |10|1080|1090|10a0|10b0||1180|1190|11a0|11b0|||1880|1890|18a0|18b0||1980|
 |11|10c0|10d0|10e0|10f0||11c0|11d0|11e0|11f0|||18c0|18d0|18e0|18f0||19c0|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
 |12|1200|1210|1220|1230||1300|1310|1320|1330|||1a00|1a10|1a20|1a30||1b00|
 |13|1240|1250|1260|1270||1340|1350|1360|1370|||1a40|1a50|1a60|1a70||1b40|
 |14|1280|1290|12a0|12b0||1380|1390|13a0|13b0|||1a80|1a90|1aa0|1ab0||1b80|
 |15|12c0|12d0|12e0|12f0||13c0|13d0|13e0|13f0|||1ac0|1ad0|1ae0|1af0||1bc0|
 +==+====+====+====+====++====+====+====+====+++====+====+====+====++====+
 |16|2000|2010|2020|2030||2100|2110|2120|2130|||2800|2810|2820|2830||2900|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
z == 1:
 x --&gt;
y+--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
||  |  0 |  1 |  2 |  3 ||  4 |  5 |  6 |  7 |||  8 |  9 | 10 | 11 || 12 |
|+--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
V| 0|0400|0410|0420|0430||0500|0510|0520|0530|||0c00|0c10|0c20|0c30||0d00|
 | 1|0440|0450|0460|0470||0540|0550|0560|0570|||0c40|0c50|0c60|0c70||0d40|
 | 2|0480|0490|04a0|04b0||0580|0590|05a0|05b0|||0c80|0c90|0ca0|0cb0||0d80|
 | 3|04c0|04d0|04e0|04f0||05c0|05d0|05e0|05f0|||0cc0|0cd0|0ce0|0cf0||0dc0|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
 | 4|0600|0610|0620|0630||0700|0710|0720|0730|||0e00|0a10|0e20|0a30||0f00|
 | 5|0640|0650|0660|0670||0740|0750|0760|0770|||0e40|0a50|0e60|0a70||0f40|
 | 6|0680|0690|06a0|06b0||0780|0790|07a0|07b0|||0e80|0a90|0ea0|0ab0||0f80|
 | 7|06c0|06d0|06e0|06f0||07c0|07d0|07e0|07f0|||0ec0|0ad0|0ee0|0af0||0fc0|
 +==+====+====+====+====++====+====+====+====+++====+====+====+====++====+
 | 8|1400|1410|1420|1430||1500|1510|1520|1530|||1c00|1c10|1c20|1c30||1d00|
 | 9|1440|1450|1460|1470||1540|1550|1560|1570|||1c40|1c50|1c60|1c70||1d40|
 |10|1480|1490|14a0|14b0||1580|1590|15a0|15b0|||1c80|1c90|1ca0|1cb0||1d80|
 |11|14c0|14d0|14e0|14f0||15c0|15d0|15e0|15f0|||1cc0|1cd0|1ce0|1cf0||1dc0|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
 |12|1600|1610|1620|1630||1700|1710|1720|1730|||1e00|1e10|1e20|1e30||1f00|
 |13|1640|1650|1660|1670||1740|1750|1760|1770|||1e40|1e50|1e60|1e70||1f40|
 |14|1680|1690|16a0|16b0||1780|1790|17a0|17b0|||1e80|1e90|1ea0|1eb0||1f80|
 |15|16c0|16d0|16e0|16f0||17c0|17d0|17e0|17f0|||1ec0|1ed0|1ee0|1ef0||1fc0|
 +==+====+====+====+====++====+====+====+====+++====+====+====+====++====+
 |16|2400|2410|2420|2430||2500|2510|2520|2530|||2c00|2c10|2c20|2c30||2d00|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
[z bigtile bounduary here]
z == 2:
 x --&gt;
y+--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
||  |  0 |  1 |  2 |  3 ||  4 |  5 |  6 |  7 |||  8 |  9 | 10 | 11 || 12 |
|+--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
V| 0|3000|3010|3020|3030||3100|3110|3120|3130|||3800|3810|3820|3830||3900|
 | 1|3040|3050|3060|3070||3140|3150|3160|3170|||3840|3850|3860|3870||3940|
 | 2|3080|3090|30a0|30b0||3180|3190|31a0|31b0|||3880|3890|38a0|38b0||3980|
 | 3|30c0|30d0|30e0|30f0||31c0|31d0|31e0|31f0|||38c0|38d0|38e0|38f0||39c0|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
 | 4|3200|3210|3220|3230||3300|3310|3320|3330|||3a00|3a10|3a20|3a30||3b00|
 | 5|3240|3250|3260|3270||3340|3350|3360|3370|||3a40|3a50|3a60|3a70||3b40|
 | 6|3280|3290|32a0|32b0||3380|3390|33a0|33b0|||3a80|3a90|3aa0|3ab0||3b80|
 | 7|32c0|32d0|32e0|32f0||33c0|33d0|33e0|33f0|||3ac0|3ad0|3ae0|3af0||3bc0|
 +==+====+====+====+====++====+====+====+====+++====+====+====+====++====+
 | 8|4000|4010|4020|4030||4100|4110|4120|4130|||4800|4810|4820|4830||4900|
 | 9|4040|4050|4060|4070||4140|4150|4160|4170|||4840|4850|4860|4870||4940|
 |10|4080|4090|40a0|40b0||4180|4190|41a0|41b0|||4880|4890|48a0|48b0||4980|
 |11|40c0|40d0|40e0|40f0||41c0|41d0|41e0|41f0|||48c0|48d0|48e0|48f0||49c0|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+
 |12|4200|4210|4220|4230||4300|4310|4320|4330|||4a00|4a10|4a20|4a30||4b00|
 |13|4240|4250|4260|4270||4340|4350|4360|4370|||4a40|4a50|4a60|4a70||4b40|
 |14|4280|4290|42a0|42b0||4380|4390|43a0|43b0|||4a80|4a90|4aa0|4ab0||4b80|
 |15|42c0|42d0|42e0|42f0||43c0|43d0|43e0|43f0|||4ac0|4ad0|4ae0|4af0||4bc0|
 +==+====+====+====+====++====+====+====+====+++====+====+====+====++====+
 |16|5000|5010|5020|2030||5100|5110|5120|5130|||5800|5810|5820|5830||5900|
 +--+----+----+----+----++----+----+----+----+++----+----+----+----++----+</pre>
</div>
</div>
<div class="section" id="textures-mipmapping-and-arrays">
<h2><a class="toc-backref" href="#id6">Textures, mipmapping and arrays</a><a class="headerlink" href="#textures-mipmapping-and-arrays" title="Permalink to this headline">¶</a></h2>
<p>A texture on NV50/NVC0 can have one of 9 types:</p>
<ul class="simple">
<li>1D: made of 1 or more mip levels, each mip level is a tiled surface with
height and depth forced to 1</li>
<li>2D: made of 1 or more mip levels, each mip level is a tiled surface with
depth forced to 1</li>
<li>3D: made of 1 or more mip levels, each mip level is a tiled surface</li>
<li>1D_ARRAY: made of some number of subtextures, each subtexture is like
a single 1D texture</li>
<li>2D_ARRAY: made of some number of subtextures, each subtexture is like
a single 2D texture</li>
<li>CUBE: made of 6 subtextures, each subtexture is like a single 2D texture -
has the same layout as a 2D_ARRAY with 6 subtextures, but different
semantics</li>
<li>BUFFER: a simple packed 1D array of elements - not a surface</li>
<li>RECT: a single linear surface, or a single tiled surface with depth forced
to 1</li>
<li>CUBE_ARRAY [NVA3+]: like 2D_ARRAY, but subtexture count has to be divisible
by 6, and groups of 6 subtextures behave like CUBE textures</li>
</ul>
<p>Types other than BUFFER and RECT are made of subtextures, which are in turn
made of mip levels, which are tiled surfaces. For such textures, only the
parameters of the first mip level of the first subtexture are specified -
parameters of the following mip levels and subtextures are calculated
automatically.</p>
<p>Each mip level has each dimension 2 times smaller than the corresponding
dimension of previous mip level, rounding down unless it would result in size
of 0. Since texture units use auto-sizing for the tile size, the bigtile sizes
will be different between mip levels. The surface for each mip level starts
right after the previous one ends. Also, the total size of the subtexture is
rounded up to the size of the 0th mip level&#8217;s bigtile size:</p>
<div class="highlight-python"><pre>mip_address[0] = subtexture_address;
mip_width[0] = texture_width;
mip_height[0] = texture_height;
mip_depth[0] = texture_depth;
mip_bytes[0] = calc_surface_bytes(mip[0]);
subtexture_bytes = mip_bytes[0];
for (i = 1; i &lt;= max_mip_level; i++) {
    mip_address[i] = mip_address[i-1] + mip_bytes[i-1];
    mip_width[i] = max(1, floor(mip_width[i-1] / 2));
    mip_height[i] = max(1, floor(mip_height[i-1] / 2));
    mip_depth[i] = max(1, floor(mip_depth[i-1] / 2));
    mip_bytes[i] = calc_surface_bytes(mip[1]);
    subtexture_bytes += mip_bytes[i];
}
subtexture_bytes = alignup(subtexture_bytes, calc_surface_bigtile_bytes(mip[0]));</pre>
</div>
<p>For 1D_ARRAY, 2D_ARRAY, CUBE and CUBE_ARRAY textures, the subtextures are
stored sequentially:</p>
<div class="highlight-python"><pre>for (i = 0; i &lt; subtexture_count; i++) {
    subtexture_address[i] = texture_address + i * subtexture_bytes;
}</pre>
</div>
<p>For more information about textures, see graph/nv50-texture.txt</p>
</div>
<div class="section" id="multisampled-surfaces">
<h2><a class="toc-backref" href="#id7">Multisampled surfaces</a><a class="headerlink" href="#multisampled-surfaces" title="Permalink to this headline">¶</a></h2>
<p>Some surfaces are used as multisampled surfaces. This includes surfaces bound
as color and zeta render targets when multisampling type is other than 1X, as
well as multisampled textures on nvc0+.</p>
<p>A multisampled surface contains several samples per pixel. A &#8220;sample&#8221; is
a single set of RGBA or depth/stencil values [depending on surface type].
These samples correspond to various points inside the pixel, called sample
positions. When a multisample surface has to be displayed, it is downsampled
to a normal surface by an operation called &#8220;resolving&#8221;.</p>
<p>nv50+ GPUs also support a variant of multisampling called &#8220;coverage sampling&#8221;
or CSAA. When CSAA is used, there are two sample types: full samples and
coverage samples. Full samples behave as in normal multisampling. Coverage
samples have assigned positions inside a pixel, but their values are not
stored in the render target surfaces when rendering. Instead, a special
component, called C or coverage, is added to the zeta surface, and for each
coverage sample, a bitmask of full samples with the same value is stored.
During the resolve process, this bitmask is used to assign different weights
to the full samples depending on the count of coverage samples with matching
values, thus improving picture quality. Note that the C component conceptually
belongs to a whole pixel, not to individual samples. However, for surface
layout purposes, its value is split into several parts, and each of the parts
is stored together with one of the samples.</p>
<p>For the most part, multisampling mode does not affect surface layout - in
fact, a multisampled render target is bound as a non-multisampled texture for
the resolving process. However, multisampling mode is vital for CSAA zeta
surface layout, and for render target storage type selection if compression is
to be used - the compression schema used is directly tied to multisampling
mode.</p>
<p>The following multisample modes exist:</p>
<ul>
<li><p class="first">mode 0x0: MS1 [1×1] - no multisampling</p>
<ul class="simple">
<li>sample 0: (0x0.8, 0x0.8) [0,0]</li>
</ul>
</li>
<li><p class="first">mode 0x1: MS2 [2×1]</p>
<ul class="simple">
<li>sample 0: (0x0.4, 0x0.4) [0,0]</li>
<li>sample 1: (0x0.c, 0x0.c) [1,0]</li>
</ul>
</li>
<li><p class="first">mode 0x2: MS4 [2×2]</p>
<ul class="simple">
<li>sample 0: (0x0.6, 0x0.2) [0,0]</li>
<li>sample 1: (0x0.e, 0x0.6) [1,0]</li>
<li>sample 2: (0x0.2, 0x0.a) [0,1]</li>
<li>sample 3: (0x0.a, 0x0.e) [1,1]</li>
</ul>
</li>
<li><p class="first">mode 0x3: MS8 [4×2]</p>
<ul class="simple">
<li>sample 0: (0x0.1, 0x0.7) [0,0]</li>
<li>sample 1: (0x0.5, 0x0.3) [1,0]</li>
<li>sample 2: (0x0.3, 0x0.d) [0,1]</li>
<li>sample 3: (0x0.7, 0x0.b) [1,1]</li>
<li>sample 4: (0x0.9, 0x0.5) [2,0]</li>
<li>sample 5: (0x0.f, 0x0.1) [3,0]</li>
<li>sample 6: (0x0.b, 0x0.f) [2,1]</li>
<li>sample 7: (0x0.d, 0x0.9) [3,1]</li>
</ul>
</li>
<li><p class="first">mode 0x4: MS2_ALT [2×1] [NVA3-]</p>
<ul class="simple">
<li>sample 0: (0x0.c, 0x0.c) [1,0]</li>
<li>sample 1: (0x0.4, 0x0.4) [0,0]</li>
</ul>
</li>
<li><p class="first">mode 0x5: MS8_ALT [4×2] [NVA3-]</p>
<ul class="simple">
<li>sample 0: (0x0.9, 0x0.5) [2,0]</li>
<li>sample 1: (0x0.7, 0x0.b) [1,1]</li>
<li>sample 2: (0x0.d, 0x0.9) [3,1]</li>
<li>sample 3: (0x0.5, 0x0.3) [1,0]</li>
<li>sample 4: (0x0.3, 0x0.d) [0,1]</li>
<li>sample 5: (0x0.1, 0x0.7) [0,0]</li>
<li>sample 6: (0x0.b, 0x0.f) [2,1]</li>
<li>sample 7: (0x0.f, 0x0.1) [3,0]</li>
</ul>
</li>
<li><p class="first">mode 0x6: ??? [NVC0-] [XXX]</p>
</li>
<li><p class="first">mode 0x8: MS4_CS4 [2×2]</p>
<ul class="simple">
<li>sample 0: (0x0.6, 0x0.2) [0,0]</li>
<li>sample 1: (0x0.e, 0x0.6) [1,0]</li>
<li>sample 2: (0x0.2, 0x0.a) [0,1]</li>
<li>sample 3: (0x0.a, 0x0.e) [1,1]</li>
<li>coverage sample 4: (0x0.5, 0x0.7), belongs to 1, 3, 0, 2</li>
<li>coverage sample 5: (0x0.9, 0x0.4), belongs to 3, 2, 1, 0</li>
<li>coverage sample 6: (0x0.7, 0x0.c), belongs to 0, 1, 2, 3</li>
<li>coverage sample 7: (0x0.b, 0x0.9), belongs to 2, 0, 3, 1</li>
</ul>
<p>C component is 16 bits per pixel, bitfields:</p>
<ul class="simple">
<li>0-3: sample 4 associations: 0, 1, 2, 3</li>
<li>4-7: sample 5 associations: 0, 1, 2, 3</li>
<li>8-11: sample 6 associations: 0, 1, 2, 3</li>
<li>12-15: sample 7 associations: 0, 1, 2, 3</li>
</ul>
</li>
<li><p class="first">mode 0x9: MS4_CS12 [2×2]
- sample 0: (0x0.6, 0x0.1) [0,0]
- sample 1: (0x0.f, 0x0.6) [1,0]
- sample 2: (0x0.1, 0x0.a) [0,1]
- sample 3: (0x0.a, 0x0.f) [1,1]
- coverage sample 4: (0x0.4, 0x0.e), belongs to 2, 3
- coverage sample 5: (0x0.c, 0x0.3), belongs to 1, 0
- coverage sample 6: (0x0.d, 0x0.d), belongs to 3, 1
- coverage sample 7: (0x0.4, 0x0.4), belongs to 0, 2
- coverage sample 8: (0x0.9, 0x0.5), belongs to 0, 1, 2
- coverage sample 9: (0x0.7, 0x0.7), belongs to 0, 2, 1, 3
- coverage sample a: (0x0.b, 0x0.8), belongs to 1, 3, 0
- coverage sample b: (0x0.3, 0x0.8), belongs to 2, 0, 3
- coverage sample c: (0x0.8, 0x0.c), belongs to 3, 2, 1
- coverage sample d: (0x0.2, 0x0.2), belongs to 0, 2
- coverage sample e: (0x0.5, 0x0.b), belongs to 2, 3, 0, 1
- coverage sample f: (0x0.e, 0x0.9), belongs to 1, 3</p>
<p>C component is 32 bits per pixel, bitfields:</p>
<ul class="simple">
<li>0-1: sample 4 associations: 2, 3</li>
<li>2-3: sample 5 associations: 0, 1</li>
<li>4-5: sample 6 associations: 1, 3</li>
<li>6-7: sample 7 associations: 0, 2</li>
<li>8-10: sample 8 associations: 0, 1, 2</li>
<li>11-14: sample 9 associations: 0, 1, 2, 3</li>
<li>15-17: sample a associations: 0, 1, 3</li>
<li>18-20: sample b associations: 0, 2, 3</li>
<li>31-23: sample c associations: 1, 2, 3</li>
<li>24-25: sample d associations: 0, 2</li>
<li>26-29: sample e associations: 0, 1, 2, 3</li>
<li>30-31: sample f associations: 1, 3</li>
</ul>
</li>
<li><p class="first">mode 0xa: MS8_CS8 [4×2]</p>
<ul class="simple">
<li>sample 0: (0x0.1, 0x0.3) [0,0]</li>
<li>sample 1: (0x0.6, 0x0.4) [1,0]</li>
<li>sample 2: (0x0.3, 0x0.f) [0,1]</li>
<li>sample 3: (0x0.4, 0x0.b) [1,1]</li>
<li>sample 4: (0x0.c, 0x0.1) [2,0]</li>
<li>sample 5: (0x0.e, 0x0.7) [3,0]</li>
<li>sample 6: (0x0.8, 0x0.8) [2,1]</li>
<li>sample 7: (0x0.f, 0x0.d) [3,1]</li>
<li>coverage sample 8: (0x0.5, 0x0.7), belongs to 1, 6, 3, 0</li>
<li>coverage sample 9: (0x0.7, 0x0.2), belongs to 1, 0, 4, 6</li>
<li>coverage sample a: (0x0.b, 0x0.6), belongs to 5, 6, 1, 4</li>
<li>coverage sample b: (0x0.d, 0x0.3), belongs to 4, 5, 6, 1</li>
<li>coverage sample c: (0x0.2, 0x0.9), belongs to 3, 0, 2, 1</li>
<li>coverage sample d: (0x0.7, 0x0.c), belongs to 3, 2, 6, 7</li>
<li>coverage sample e: (0x0.a, 0x0.e), belongs to 7, 3, 2, 6</li>
<li>coverage sample f: (0x0.c, 0x0.a), belongs to 5, 6, 7, 3</li>
</ul>
<p>C component is 32 bits per pixel, bitfields:</p>
<ul class="simple">
<li>0-3: sample 8 associations: 0, 1, 3, 6</li>
<li>4-7: sample 8 associations: 0, 1, 4, 6</li>
<li>8-11: sample 8 associations: 1, 4, 5, 6</li>
<li>12-15: sample 8 associations: 1, 4, 5, 6</li>
<li>16-19: sample 8 associations: 0, 1, 2, 3</li>
<li>20-23: sample 8 associations: 2, 3, 6, 7</li>
<li>24-27: sample 8 associations: 2, 3, 6, 7</li>
<li>28-31: sample 8 associations: 3, 5, 6, 7</li>
</ul>
</li>
<li><p class="first">mode 0xb: MS8_CS24 [NVC0-]</p>
</li>
</ul>
<div class="admonition-todo admonition" id="index-5">
<p class="first admonition-title">Todo</p>
<p class="last">wtf is up with modes 4 and 5?</p>
</div>
<div class="admonition-todo admonition" id="index-6">
<p class="first admonition-title">Todo</p>
<p class="last">nail down MS8_CS24 sample positions</p>
</div>
<div class="admonition-todo admonition" id="index-7">
<p class="first admonition-title">Todo</p>
<p class="last">figure out mode 6</p>
</div>
<div class="admonition-todo admonition" id="index-8">
<p class="first admonition-title">Todo</p>
<p class="last">figure out MS8_CS24 C component</p>
</div>
<p>Note that MS8 and MS8_C* modes cannot be used with surfaces that have 16-byte
element size due to a hardware limitation. Also, multisampling is only
possible with tiled surfaces.</p>
<div class="admonition-todo admonition" id="index-9">
<p class="first admonition-title">Todo</p>
<p class="last">check MS8/128bpp on NVC0.</p>
</div>
<p>The sample ids are, for full samples, the values appearing in the sampleid
register. The numbers in () are the geometric coordinates of the sample
inside a pixel, as used by the rasterization process. The dimensions in []
are dimensions of a block represents a pixel in the surface - if it&#8217;s 4×2,
each pixel is represented in the surface as a block 4 elements wide and 2
elements tall. The numbers in [] after each full sample are the coordinates
inside this block.</p>
<p>Each coverage sample &#8220;belongs to&#8221; several full samples. For every such pair
of coverage sample and full sample, the C component contains a bit that tells
if the coverage sample&#8217;s value is the same as the full one&#8217;s, ie. if the last
rendered primitive that covered the full sample also covered the coverage
sample. When the surface is resolved, each sample will &#8220;contribute&#8221; to exactly
one full sample. The full samples always contribute to themselves, while
coverage sample will contribute to the first full sample that they belong to,
in order listed above, that has the relevant bit set in C component of the
zeta surface. If none of the C bits for a given coverage sample are set, the
sample will default to contributing to the first sample in its belongs list.
Then, for each full sample, the number of samples contributing to it is
counted, and used as its weight when performing the downsample calculation.</p>
<p>Note that, while the belongs list orderings are carefully chosen based on
sample locations and to even the weights, the bits in C component don&#8217;t use
this ordering and are sorted by sample id instead.</p>
<p>The C component is 16 or 32 bits per pixel, depending on the format. It is
then split into 8-bit chunks, starting from LSB, and each chunk is assigned
to one of the full samples. For MS4_CS4 and MS8_CS8, only samples in the top
line of each block get a chunk assigned, for MS4_CS12 all samples get a chunk.
The chunks are assigned to samples ordered first by x coordinate of the
sample, then by its y coordinate.</p>
</div>
<div class="section" id="surface-formats">
<h2><a class="toc-backref" href="#id8">Surface formats</a><a class="headerlink" href="#surface-formats" title="Permalink to this headline">¶</a></h2>
<p>A surface&#8217;s format determines the type of information it stores in its
elements, the element size, and the element layout. Not all binding points
care about the format - m2mf and PCOPY treat all surfaces as arrays of bytes.
Also, format specification differs a lot between the binding points that make
use of it - 2d engine and render targets use a big enum of valid formats,
with values specifying both the layout and components, while texture
units decouple layout specification from component assignment and type
selection, allowing arbitrary swizzles.</p>
<p>There are 3 main enums used for specifying surface formats:</p>
<ul class="simple">
<li>texture format: used for textures, epecifies element size and layout, but
not the component assignments nor type</li>
<li>color format: used for color RTs and the 2d engine, specifies the full
format</li>
<li>zeta format: used for zeta RTs, specifies the full format, except the
specific coverage sampling mode, if applicable</li>
</ul>
<p>The surface formats can be broadly divided into the following categories:</p>
<ul class="simple">
<li>simple color formats: elements correspond directly to samples. Each element
has 1 to 4 bitfields corresponding to R, G, B, A components. Usable for
texturing, color RTs, and 2d engine.</li>
<li>shared exponent color format: like above, but the components are floats
sharing the exponent bitfield. Usable for texturing only.</li>
<li>YUV color formats: element corresponds to two pixels lying in the same
horizontal line. The pixels have three components, conventionally labeled
as Y, U, V. U and V components are common for the two pixels making up an
element, but Y components are separate. Usable for texturing only.</li>
<li>zeta formats: elements correspond to samples. There is a per-sample depth
component, optionally a per-sample stencil component, and optionally a
per-pixel coverage value for CSAA surfaces. Usable for texturing and ZETA
RT.</li>
<li>compressed texture formats: elements correspond to blocks of samples, and
are decoded to RGBA color values on the fly. Can be used only for
texturing.</li>
<li>bitmap texture format: each element corresponds to 8x8 block of samples,
with 1 bit per sample. Has to be used with a special texture sampler.
Usable for texturing and 2d engine.</li>
</ul>
<div class="admonition-todo admonition" id="index-10">
<p class="first admonition-title">Todo</p>
<p class="last">wtf is color format 0x1d?</p>
</div>
<div class="section" id="simple-color-surface-formats">
<h3><a class="toc-backref" href="#id9">Simple color surface formats</a><a class="headerlink" href="#simple-color-surface-formats" title="Permalink to this headline">¶</a></h3>
<p>A simple color surface is a surface where each element corresponds directly to
a sample, each sample has 4 components known as R, G, B, A [in that order], and
the bitfields in element correspond directly to components. There can be less
bitfields than components - the remaining components will be ignored on write,
and get a default value on read, which is 0 for R, G, B and 1 for A.</p>
<p>When bound to texture unit, the simple color formats are specified in three
parts. First, the format is specified, which is an enumerated value shared
with other format types. This format specifies the format type and, for simple
color formats, element size, and location of bitfields inside the element.
Then, the type [float/sint/uint/unorm/snorm] of each element component is
specified. Finally, a swizzle is specified: each of the 4 component outputs
[R, G, B, A] from the texture unit can be mapped to any of the components
present in the element [called C0-C3], constant 0, integer constant 1, or
float constant 1.</p>
<p>Thanks to the swizzle capability, there&#8217;s no need to support multiple
orderings in the format itself, and all simple color texture formats have
C0 bitfield starting at LSB of the first byte, C1 [if present] at the first
bit after C0, and so on. Thus it&#8217;s enough to specify bitfield lengths to
uniquely identify a texture type: for example 5_5_6 is a format with 3
components and element size of 2 bytes, C0 at bits 0-4, C1 at bits 5-9,
and C2 at bits 10-15. The element is always treated as a little-endian word
of the proper size, and bitfields are listed from LSB side. Also, in some
cases the texture format has bitfields used only for padding, and not usable
as components: these will be listed in the name as X&lt;size&gt;. For example,
32_8_X24 is a format with element size of 8 bytes, where bits 0-31 are C0,
32-39 are C1, and 40-63 are unusable.
[XXX: what exactly happens to element layout in big-endian mode?]</p>
<p>However, when bound to RTs or the 2d engine, all of the format, including
element size, element layout, component types, component assignment, and SRGB
flag, is specified by a single enumerated value. These formats have
a many-to-one relationship to texture formats, and are listed here below the
corresponding one. The information listed here for a format is C0-C3
assignments to actual components and component type, plus SRGB flag where
applicable. The components can be R, G, B, A, representing a bitfield
corresponding directly to a single component, X representing an unused
bitfield, or Y representing a bitfield copied to all components on read,
and filled with the R value on write.</p>
<p>The formats are:</p>
<p>Element size 16:</p>
<ul class="simple">
<li>texture format 0x01: 32_32_32_32<ul>
<li>color format 0xc0: RGBA, float</li>
<li>color format 0xc1: RGBA, sint</li>
<li>color format 0xc2: RGBA, uint</li>
<li>color format 0xc3: RGBX, float</li>
<li>color format 0xc4: RGBX, sint</li>
<li>color format 0xc5: RGBX, uint</li>
</ul>
</li>
</ul>
<p>Element size 8:</p>
<ul class="simple">
<li>texture format 0x03: 16_16_16_16<ul>
<li>color format 0xc6: RGBA, unorm</li>
<li>color format 0xc7: RGBA, snorm</li>
<li>color format 0xc8: RGBA, sint</li>
<li>color format 0xc9: RGBA, uint</li>
<li>color format 0xca: RGBA, float</li>
<li>color format 0xce: RGBX, float</li>
</ul>
</li>
<li>texture format 0x04: 32_32<ul>
<li>color format 0xcb: RG, float</li>
<li>color format 0xcc: RG, sint</li>
<li>color format 0xcd: RG, uint</li>
</ul>
</li>
<li>texture format 0x05: 32_8_X24</li>
</ul>
<p>Element size 4:</p>
<ul class="simple">
<li>texture format 0x07: 8_8_8_X8</li>
</ul>
<div class="admonition-todo admonition" id="index-11">
<p class="first admonition-title">Todo</p>
<p class="last">htf do I determine if a surface format counts as 0x07 or 0x08?</p>
</div>
<ul class="simple">
<li>texture format 0x08: 8_8_8_8<ul>
<li>color format 0xcf: BGRA, unorm</li>
<li>color format 0xd0: BGRA, unorm, SRGB</li>
<li>color format 0xd5: RGBA, unorm</li>
<li>color format 0xd6: RGBA, unorm, SRGB</li>
<li>color format 0xd7: RGBA, snorm</li>
<li>color format 0xd8: RGBA, sint</li>
<li>color format 0xd9: RGBA, uint</li>
<li>color format 0xe6: BGRX, unorm</li>
<li>color format 0xe7: BGRX, unorm, SRGB</li>
<li>color format 0xf9: RGBX, unorm</li>
<li>color format 0xfa: RGBX, unorm, SRGB</li>
<li>color format 0xfd: BGRX, unorm [XXX]</li>
<li>color format 0xfe: BGRX, unorm [XXX]</li>
</ul>
</li>
<li>texture format 0x09: 10_10_10_2<ul>
<li>color format 0xd1: RGBA, unorm</li>
<li>color format 0xd2: RGBA, uint</li>
<li>color format 0xdf: BGRA, unorm</li>
</ul>
</li>
<li>texture format 0x0c: 16_16<ul>
<li>color format 0xda: RG, unorm</li>
<li>color format 0xdb: RG, snorm</li>
<li>color format 0xdc: RG, sint</li>
<li>color format 0xdd: RG, uint</li>
<li>color format 0xde: RG, float</li>
</ul>
</li>
<li>texture format 0x0d: 24_8</li>
<li>texture format 0x0e: 8_24</li>
<li>texture format 0x0f: 32<ul>
<li>color format 0xe3: R, sint</li>
<li>color format 0xe4: R, uint</li>
<li>color format 0xe5: R, float</li>
<li>color format 0xff: Y, uint [XXX]</li>
</ul>
</li>
<li>texture format 0x21: 11_11_10<ul>
<li>color format 0xe0: RGB, float</li>
</ul>
</li>
</ul>
<p>Element size 2:</p>
<ul class="simple">
<li>texture format 0x12: 4_4_4_4</li>
<li>texture format 0x13: 1_5_5_5</li>
<li>texture format 0x14: 5_5_5_1<ul>
<li>color format 0xe9: BGRA, unorm</li>
<li>color format 0xf8: BGRX, unorm</li>
<li>color format 0xfb: BGRX, unorm [XXX]</li>
<li>color format 0xfc: BGRX, unorm [XXX]</li>
</ul>
</li>
<li>texture format 0x15: 5_6_5<ul>
<li>color format 0xe8: BGR, unorm</li>
</ul>
</li>
<li>texture format 0x16: 5_5_6</li>
<li>texture format 0x18: 8_8<ul>
<li>color format 0xea: RG, unorm</li>
<li>color format 0xeb: RG, snorm</li>
<li>color format 0xec: RG, uint</li>
<li>color format 0xed: RG, sint</li>
</ul>
</li>
<li>texture format 0x1b: 16<ul>
<li>color format 0xee: R, unorm</li>
<li>color format 0xef: R, snorm</li>
<li>color format 0xf0: R, sint</li>
<li>color format 0xf1: R, uint</li>
<li>color format 0xf2: R, float</li>
</ul>
</li>
</ul>
<p>Element size 1:</p>
<ul class="simple">
<li>texture format 0x1d: 8<ul>
<li>color format 0xf3: R, unorm</li>
<li>color format 0xf4: R, snorm</li>
<li>color format 0xf5: R, sint</li>
<li>color format 0xf6: R, uint</li>
<li>color format 0xf7: A, unorm</li>
</ul>
</li>
<li>texture format 0x1e: 4_4</li>
</ul>
<div class="admonition-todo admonition" id="index-12">
<p class="first admonition-title">Todo</p>
<p class="last">which component types are valid for a given bitfield size?</p>
</div>
<div class="admonition-todo admonition" id="index-13">
<p class="first admonition-title">Todo</p>
<p class="last">clarify float encoding for weird sizes</p>
</div>
</div>
<div class="section" id="shared-exponent-color-format">
<h3><a class="toc-backref" href="#id10">Shared exponent color format</a><a class="headerlink" href="#shared-exponent-color-format" title="Permalink to this headline">¶</a></h3>
<p>A shared exponent color format is like a simple color format, but there&#8217;s
an extra bitfield, called E, that&#8217;s used as a shared exponent for C0-C2. The
remaining three bitfields correspond to the mantissas of C0-C2, respectively.
They can be swizzled arbitrarily, but they have to use the float type.</p>
<p>Element size 4:</p>
<ul class="simple">
<li>texture format 0x20: 9_9_9_E5</li>
</ul>
</div>
<div class="section" id="yuv-color-formats">
<h3><a class="toc-backref" href="#id11">YUV color formats</a><a class="headerlink" href="#yuv-color-formats" title="Permalink to this headline">¶</a></h3>
<p>These formats are also similar to color formats. However, The components are
conventionally called Y, U, V: C0 is known as U, C1 is known as Y, and C2 is
known as V. An element represents two pixels, and has 4 bitfields: YA
representing Y value for first pixel, YB representing Y value for second
pixel, U representing U value for both pixels, and V representing V value
of both pixels. There are two YUV formats, differing in bitfield order:</p>
<p>Element size 4:</p>
<ul class="simple">
<li>texture format 0x21: U8_YA8_V8_YB8</li>
<li>texture format 0x22: YA8_U8_YB8_V8</li>
</ul>
<div class="admonition-todo admonition" id="index-14">
<p class="first admonition-title">Todo</p>
<p class="last">verify I haven&#8217;t screwed up the ordering here</p>
</div>
</div>
<div class="section" id="zeta-surface-format">
<h3><a class="toc-backref" href="#id12">Zeta surface format</a><a class="headerlink" href="#zeta-surface-format" title="Permalink to this headline">¶</a></h3>
<p>A zeta surface, like a simple color surface, has one element per sample.
It contains up to three components: the depth component [called Z], optionally
the stencil component [called S], and if coverage sampling is in use, the
coverage component [called C].</p>
<p>The Z component can be a 32-bit float, a 24-bit normalized unsinged integer, or
[on NVA0+] a 16-bit normalized unsigned integer. The S component, if present,
is always an 8-bit raw integer.</p>
<p>The C component is special: if present, it&#8217;s an 8-bit bitfield in each sample.
However, semantically it is a per-pixel value, and the values of the samples&#8217;
C components are stitched together to obtain a per-pixel value. This stitching
process depends on the multisample mode, thus it needs to be specified to
bind a coverage sampled zeta surface as a texture. It&#8217;s not allowed to use
a coverage sampling mode with a zeta format without C component, or the other
way around.</p>
<p>Like with color formats, there are two different enums that specify zeta
formats: texture formats and zeta formats. However, this time the zeta formats
have one-to-many relationship with texture formats: Texture format contains
information about the specific coverage sampling mode used, while zeta format
merely says whether coverage sampling is in use, and the mode is taken from
RT multisample configuration.</p>
<p>For textures, Z corresponds to C0, S to C1, and C to C2. However, C cannot
be used together with Z and/or S in a single sampler. Z and S sampling works
normally, but when C is sampled, the sampler returns preprocessed weights
instead of the raw value - see graph/nv50-texture.txt for more information
about the sampling process.</p>
<p>The formats are:</p>
<p>Element size 2:</p>
<ul class="simple">
<li>zeta format 0x13: Z16 [NVA0+ only]<ul>
<li>texture format 0x3a: Z16 [NVA0+ only]</li>
</ul>
</li>
</ul>
<p>Element size 4:</p>
<ul class="simple">
<li>zeta format 0x0a: Z32<ul>
<li>texture format 0x2f</li>
</ul>
</li>
<li>zeta format 0x14: S8_Z24<ul>
<li>texture format 0x29</li>
</ul>
</li>
<li>zeta format 0x15: Z24_X8<ul>
<li>texture format 0x2b</li>
</ul>
</li>
<li>zeta format 0x16: Z24_S8<ul>
<li>texture format 0x2a</li>
</ul>
</li>
<li>zeta format 0x18: Z24_C8<ul>
<li>texture format 0x2c: MS4_CS4</li>
<li>texture format 0x2d: MS8_CS8</li>
<li>texture format 0x2e: MS4_CS12</li>
</ul>
</li>
</ul>
<p>Element size 8:</p>
<ul class="simple">
<li>zeta format 0x19: Z32_S8_X24<ul>
<li>texture format 0x30</li>
</ul>
</li>
<li>zeta format 0x1d: Z24_X8_S8_C8_X16<ul>
<li>texture format 0x31: MS4_CS4</li>
<li>texture format 0x32: MS8_CS8</li>
<li>texture format 0x37: MS4_CS12</li>
</ul>
</li>
<li>zeta format 0x1e: Z32_X8_C8_X16<ul>
<li>texture format 0x33: MS4_CS4</li>
<li>texture format 0x34: MS8_CS8</li>
<li>texture format 0x38: MS4_CS12</li>
</ul>
</li>
<li>zeta format 0x1f: Z32_S8_C8_X16<ul>
<li>texture format 0x35: MS4_CS4</li>
<li>texture format 0x36: MS8_CS8</li>
<li>texture format 0x39: MS4_CS12</li>
</ul>
</li>
</ul>
<div class="admonition-todo admonition" id="index-15">
<p class="first admonition-title">Todo</p>
<p class="last">figure out the MS8_CS24 formats</p>
</div>
</div>
<div class="section" id="compressed-texture-formats">
<h3><a class="toc-backref" href="#id13">Compressed texture formats</a><a class="headerlink" href="#compressed-texture-formats" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-16">
<p class="first admonition-title">Todo</p>
<p class="last">write me</p>
</div>
</div>
<div class="section" id="bitmap-surface-format">
<h3><a class="toc-backref" href="#id14">Bitmap surface format</a><a class="headerlink" href="#bitmap-surface-format" title="Permalink to this headline">¶</a></h3>
<p>A bitmap surface has only one component, and the component has 1 bit per sample
- that is, the component&#8217;s value can be either 0 or 1 for each sample in the
surface. The surface is made of 8-byte elements, with each element
representing 8×8 block of samples. The element is treated as a 64-bit word,
with each sample taking 1 bit. The bits start from LSB and are ordered first
by x coordinate of the sample, then by its y coordinate.</p>
<p>This format can be used for 2d engine and texturing. When used for texturing,
it forces using a special &#8220;box&#8221; filter: result of sampling is a percentage of
&#8220;lit&#8221; area in WxH rectangle centered on the sampled location. See
graph/nv50-texture.txt for more details.</p>
<div class="admonition-todo admonition" id="index-17">
<p class="first admonition-title">Todo</p>
<p class="last">figure out more. Check how it works with 2d engine.</p>
</div>
<p>The formats are:</p>
<p>Element size 8:</p>
<ul class="simple">
<li>texture format 0x1f: BITMAP<ul>
<li>color format 0x1c: BITMAP</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="nv50-storage-types">
<h2><a class="toc-backref" href="#id15">NV50 storage types</a><a class="headerlink" href="#nv50-storage-types" title="Permalink to this headline">¶</a></h2>
<p>On nv50, the storage type is made of two parts: the storage type itself, and
the compression mode. The storage type is a 7-bit enum, the compression mode
is a 2-bit enum.</p>
<p>The compression modes are:</p>
<ul class="simple">
<li>0: NONE - no compression</li>
<li>1: SINGLE - 2 compression tag bits per roptile, 1 tag cell per 64kB page</li>
<li>2: DOUBLE - 4 compression tag bits per roptile, 2 tag cells per 64kB page</li>
</ul>
<div class="admonition-todo admonition" id="index-18">
<p class="first admonition-title">Todo</p>
<p class="last">verify somehow.</p>
</div>
<p>The set of valid compression modes varies with the storage type. NONE is
always valid.</p>
<p>As mentioned before, the low-level rearrangement is further split into two
sublevels: short range reordering, rearranging bytes in a single roptile,
and long range reordering, rearranging roptiles. Short range reordering
is performed for both VRAM and system RAM, and is highly dependent on the
storage type. Long range reordering is done only for VRAM, and has only three
types:</p>
<ul class="simple">
<li>none [NONE] - no reordering, only used for storage type 0 [linear]</li>
<li>small scale [SSR] - roptiles rearranged inside a single 4kB page, used for
non-0 storage types</li>
<li>large scale [LSR] - large blocks of memory rearranged, based on internal
VRAM geometry. Bounduaries between VRAM areas using NONE/SSR and LSR need
to be properly aligned in physical space to prevent conflicts.</li>
</ul>
<p>Long range reordering is described in detail in <a class="reference internal" href="nv50-vram.html#nv50-vram"><em>NV50:NVC0 VRAM structure and usage</em></a>.</p>
<p>The storage types can be roughly split into the following groups:</p>
<ul class="simple">
<li>linear storage type: used for linear surfaces and non-surface buffers</li>
<li>tiled color storage types: used for non-zeta tiled surfaces</li>
<li>zeta storage types: used for zeta surfaces</li>
</ul>
<p>On the original nv50, non-0 storage types can only be used on VRAM, on NV84
and later cards they can also be used on system RAM. Compression modes other
than NONE can only be used on VRAM. However, due to the nv50 limitation, tiled
surfaces stored in system RAM are allowed to use storage type 0, and will work
correctly for texturing and m2mf source/destination - rendering to them with
2d or 3d engine is impossible, though.</p>
<p>Correct storage types are only enforced by texture units and ROPs [ie. 2d and
3d engine render targets + CUDA global/local/stack spaces], which have
dedicated paths to memory and depend on the storage types for performance. The
other engines have storage type handling done by the common memory controller
logic, and will accept any storage type.</p>
<p>The linear storage type is:</p>
<dl class="docutils">
<dt>storage type 0x00: LINEAR</dt>
<dd>long range reordering: NONE
valid compression modes: NONE
There&#8217;s no short range reordering on this storage type - the offset inside
a roptile is identical between the virtual and physical addresses.</dd>
</dl>
<div class="section" id="tiled-color-storage-types">
<h3><a class="toc-backref" href="#id16">Tiled color storage types</a><a class="headerlink" href="#tiled-color-storage-types" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-19">
<p class="first admonition-title">Todo</p>
<p class="last">reformat</p>
</div>
<p>The following tiled color storage types exist:</p>
<dl class="docutils">
<dt>storage type 0x70: TILED</dt>
<dd>long range reordering: SSR
valid compression modes: NONE
valid surface formats: any non-zeta with element size of 1, 2, 4, or 8 bytes
valid multisampling modes: any</dd>
<dt>storage type 0x72: TILED_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE
valid surface formats: any non-zeta with element size of 1, 2, 4, or 8 bytes
valid multisampling modes: any</dd>
<dt>storage type 0x76: TILED_128_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE
valid surface formats: any non-zeta with element size of 16 bytes
valid multisampling modes: any</dd>
</dl>
<p>[XXX]</p>
<dl class="docutils">
<dt>storage type 0x74: TILED_128</dt>
<dd>long range reordering: SSR
valid compression modes: NONE
valid surface formats: any non-zeta with element size of 16 bytes
valid multisampling modes: any</dd>
</dl>
<p>[XXX]</p>
<dl class="docutils">
<dt>storage type 0x78: TILED_32_MS4</dt>
<dd>long range reordering: SSR
valid compression modes: NONE, SINGLE
valid surface formats: any non-zeta with element size of 4 bytes
valid multisampling modes: MS1, MS2*, MS4*</dd>
<dt>storage type 0x79: TILED_32_MS8</dt>
<dd>long range reordering: SSR
valid compression modes: NONE, SINGLE
valid surface formats: any non-zeta with element size of 4 bytes
valid multisampling modes: MS8*</dd>
<dt>storage type 0x7a: TILED_32_MS4_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE, SINGLE
valid surface formats: any non-zeta with element size of 4 bytes
valid multisampling modes: MS1, MS2*, MS4*</dd>
<dt>storage type 0x7b: TILED_32_MS8_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE, SINGLE
valid surface formats: any non-zeta with element size of 4 bytes
valid multisampling modes: MS8*</dd>
</dl>
<p>[XXX]</p>
<dl class="docutils">
<dt>storage type 0x7c: TILED_64_MS4</dt>
<dd>long range reordering: SSR
valid compression modes: NONE, SINGLE
valid surface formats: any non-zeta with element size of 8 bytes
valid multisampling modes: MS1, MS2*, MS4*</dd>
<dt>storage type 0x7d: TILED_64_MS8</dt>
<dd>long range reordering: SSR
valid compression modes: NONE, SINGLE
valid surface formats: any non-zeta with element size of 8 bytes
valid multisampling modes: MS8*</dd>
</dl>
<p>[XXX]</p>
<dl class="docutils">
<dt>storage type 0x44: TILED_24</dt>
<dd>long range reordering: SSR
valid compression modes: NONE
valid surface formats: texture format 8_8_8_X8 and corresponding color formats
valid multisampling modes: any</dd>
<dt>storage type 0x45: TILED_24_MS4</dt>
<dd>long range reordering: SSR
valid compression modes: NONE, SINGLE
valid surface formats: texture format 8_8_8_X8 and corresponding color formats
valid multisampling modes: MS1, MS2*, MS4*</dd>
<dt>storage type 0x46: TILED_24_MS8</dt>
<dd>long range reordering: SSR
valid compression modes: NONE, SINGLE
valid surface formats: texture format 8_8_8_X8 and corresponding color formats
valid multisampling modes: MS8*</dd>
<dt>storage type 0x4b: TILED_24_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE
valid surface formats: texture format 8_8_8_X8 and corresponding color formats
valid multisampling modes: any</dd>
<dt>storage type 0x4c: TILED_24_MS4_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE, SINGLE
valid surface formats: texture format 8_8_8_X8 and corresponding color formats
valid multisampling modes: MS1, MS2*, MS4*</dd>
<dt>storage type 0x4d: TILED_24_MS8_LSR</dt>
<dd>long range reordering: LSR
valid compression modes: NONE, SINGLE
valid surface formats: texture format 8_8_8_X8 and corresponding color formats
valid multisampling modes: MS8*</dd>
</dl>
<p>[XXX]</p>
</div>
<div class="section" id="zeta-storage-types">
<h3><a class="toc-backref" href="#id17">Zeta storage types</a><a class="headerlink" href="#zeta-storage-types" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-20">
<p class="first admonition-title">Todo</p>
<p class="last">write me</p>
</div>
</div>
</div>
<div class="section" id="nvc0-storage-types">
<h2><a class="toc-backref" href="#id18">NVC0 storage types</a><a class="headerlink" href="#nvc0-storage-types" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="index-21">
<p class="first admonition-title">Todo</p>
<p class="last">write me</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">NV50- surface formats</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#surface-elements">Surface elements</a></li>
<li><a class="reference internal" href="#linear-surfaces">Linear surfaces</a></li>
<li><a class="reference internal" href="#tiled-surfaces">Tiled surfaces</a></li>
<li><a class="reference internal" href="#textures-mipmapping-and-arrays">Textures, mipmapping and arrays</a></li>
<li><a class="reference internal" href="#multisampled-surfaces">Multisampled surfaces</a></li>
<li><a class="reference internal" href="#surface-formats">Surface formats</a><ul>
<li><a class="reference internal" href="#simple-color-surface-formats">Simple color surface formats</a></li>
<li><a class="reference internal" href="#shared-exponent-color-format">Shared exponent color format</a></li>
<li><a class="reference internal" href="#yuv-color-formats">YUV color formats</a></li>
<li><a class="reference internal" href="#zeta-surface-format">Zeta surface format</a></li>
<li><a class="reference internal" href="#compressed-texture-formats">Compressed texture formats</a></li>
<li><a class="reference internal" href="#bitmap-surface-format">Bitmap surface format</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nv50-storage-types">NV50 storage types</a><ul>
<li><a class="reference internal" href="#tiled-color-storage-types">Tiled color storage types</a></li>
<li><a class="reference internal" href="#zeta-storage-types">Zeta storage types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nvc0-storage-types">NVC0 storage types</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nv44-host-mem.html"
                        title="previous chapter">NV44 host memory interface</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nv50-vm.html"
                        title="next chapter">NV50 virtual memory</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/memory/nv50-surface.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="nv50-vm.html" title="NV50 virtual memory"
             >next</a> |</li>
        <li class="right" >
          <a href="nv44-host-mem.html" title="NV44 host memory interface"
             >previous</a> |</li>
        <li><a href="../index.html">envytools git documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory access and structure</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Marcin Kościelnicki.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>